# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18T9jA1HfA9VWsfXdsffcJ_BSORoj01DY
"""

# ============================================
# Math4AI - Programming Assignment 2
# Systems of Linear Equations & Model Fitting
# ============================================

# --- Imports --- b
import numpy as np

# --- Example System ---
A = [
    [2, 1, 3],
    [4, 4, 7],
    [2, 5, 9]
]
b = [1, 1, 3]

# =====================================================
# PART 2.1: Gaussian Elimination from Scratch
# =====================================================
def gaussian_elimination(A, b):
    """
    Solve Ax = b using Gaussian elimination with partial pivoting.
    Returns:
        - list: solution vector x if unique solution exists
        - str: 'No solution' if inconsistent
        - str: 'Infinite solutions' if system has free variables
    """
    # TODO: Convert A and b into augmented matrix form
    assert len(A) == len(b), "Dimension mismatch"
    all_zero_A = True #checking 0 matrices
    for i in range(len(A)):
        for j in range(len(A[0])):
            if A[i][j] != 0:
                all_zero_A = False
                break
        if not all_zero_A:
            break
    all_zero_b = True
    for i in range(len(b)):
        if b[i] != 0:
            all_zero_b = False
            break

    if all_zero_A:
        if all_zero_b:
            return "Infinite solutions"
        else:
            return "No solution"


    M = []
    for i in range(len(A)):
        # copy the row to avoid modifying the original A
        row1 = A[i][:]
        row1.append(b[i])
        M.append(row1)

    rows = len(M)
    cols = len(M[0]) - 1

    # TODO: Detect and handle division by zero via row swaps
    for i in range(rows):
        # finding the row with the largest absolute value in the current column (partial pivoting)
        max_val = abs(M[i][i])
        pivot_row = i
        for k in range(i + 1, rows):
            if abs(M[k][i]) > max_val:
                max_val = abs(M[k][i])
                pivot_row = k
        # Swap the rows
        M[i], M[pivot_row] = M[pivot_row], M[i]

    # TODO: Implement forward elimination (with pivoting)
    for i in range(rows):
        pivot = M[i][i]
        if abs(pivot) < 1e-6: # check if pivot is effectively zero
            continue

        # eliminating other entries in the column below the pivot
        for j in range(i + 1, rows):
            element2 = M[j][i]
            if abs(element2) > 1e-6: # perform elimination if the element isn't zero
                factor = element2 / pivot
                for d in range(i, cols + 1):
                    M[j][d] -= factor * M[i][d]

    # TODO: Detect 'No solution' and 'Infinite solutions' cases
    pivot_count = 0
    for i in range(rows):
        is_zero_row = True
        for j in range(cols):
            if abs(M[i][j]) > 1e-6:
                is_zero_row = False
                break
        if not is_zero_row:
            pivot_count += 1

    # checking for inconsistent system (0 = nonzero)
    for i in range(rows):
        is_zero_A_part = True
        for j in range(cols):
            if abs(M[i][j]) > 1e-6:
                is_zero_A_part = False
                break
        if is_zero_A_part and abs(M[i][cols]) > 1e-6:
            return "No solution"

    # Check for infinite solutions (rank < number of variables)
    if pivot_count < cols:
        return "Infinite solutions"

    # TODO: Implement back substitution for unique solution case
    x = [0.0] * cols
    for i in range(cols - 1, -1, -1):
        rhs = M[i][cols]
        for j in range(i + 1, cols):
            rhs -= M[i][j] * x[j]

        # in unique solution case, the pivot must be nonzero
        pivot = M[i][i]
        if abs(pivot) < 1e-6:
            return "zero pivot in unique solution case!!!!!!"

        x[i] = rhs / pivot

    return x


# --- Solve using your function ---
solution_scratch = gaussian_elimination(A, b)
print("Solution (from scratch):", solution_scratch)


# =====================================================
# PART 2.2: NumPy Verification
# =====================================================

# Convert to NumPy arrays
np_A = np.array(A, dtype=float)
np_b = np.array(b, dtype=float)

try:
   np_solution = np.linalg.solve(np_A, np_b)
   print("Solution (NumPy):", np_solution)
except np.linalg.LinAlgError as e:
      print("NumPy could not solve the system:", e)


# =====================================================
# Verification
# =====================================================
# TODO: Compare scratch implementation result with NumPy result if unique

if type(solution_scratch) != str:  # yeni no solution ve Infinite solutions olmayanda tetbiq olunacaq
    same = True
    for i in range(len(solution_scratch)):
        if round(solution_scratch[i], 6) != round(np_solution[i], 6):
            same = False
            break
    if same:
        print("Solutions match :))")
    else:
        print("Solutions do not match :(")