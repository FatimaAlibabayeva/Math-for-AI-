# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16LGkMmH-2FCLW1IMub9-62aqNPnEh1-U
"""

#Math4AI: Linear Algebra - Programming Assignment 3
# Starter Code Template

import numpy as np
from scipy.linalg import lu as scipy_lu # Used for verification

# --- Helper Function for Pretty Printing ---
def print_matrix(name, m):
    """
    Helper function to print a matrix with its name.
    Handles None for non-invertible matrices.
    """
    print(f"{name}:")
    if m is None:
        print("None (Matrix is singular or function not implemented)")
    else:
        # Set print options for better readability
        np.set_printoptions(precision=4, suppress=True)
        print(m)
    print("-" * 30)

# --- Problem Setup ---
# The matrix A for this assignment
A = np.array([
    [2., 1., 3.],
    [4., 4., 7.],
    [2., 5., 9.]
])

print_matrix("Original Matrix A", A)

# ====================================================================
# Part 3.1: Matrix Inverse via Gauss-Jordan Elimination
# ====================================================================

def invert_matrix(A):
    """
    Computes the inverse of a square matrix A using Gauss-Jordan elimination.

    Args:
        A (np.ndarray): A square numpy array.

    Returns:
        np.ndarray: The inverse of A, or None if A is singular.
    """
    # Ensure the matrix is a float type for division
    A = A.astype(float)

    # Check if the matrix is square
    n = A.shape[0]
    if A.shape[1] != n:
        raise ValueError("Input matrix must be square.")

    # 1. Create the augmented matrix [A | I]
    identity = np.identity(n)
    augmented_A = np.hstack((A, identity))
    print("Initial Augmented Matrix [A|I]:")
    print(augmented_A)
    print("\nStarting Gauss-Jordan Elimination...")

    # --- YOUR CODE HERE ---
    # Implement the Gauss-Jordan elimination algorithm to transform
    # the left side (A) of the augmented matrix into the identity matrix.
    # The right side will then become the inverse.

    for i in range(n):
        if augmented_A[i,i]==0: # 1st part
            raise ValueError("Matrix is singular or zero pivot encountered.") # row swap etmedim cunki sertde ele yazilib
        augmented_A[i]/=augmented_A[i,i]

        for j in range(n):
            if i!=j:
                factor=augmented_A[j][i]
                augmented_A[j]-=factor*augmented_A[i]

    if not all(all(abs(augmented_A[i,j] - (1 if i==j else 0))<1e-9 for j in range(n))for i in range(n)): # eger pivot olsa 1 cixilir ozunden, eks halda ise 0 ve bu halda cavab 0 i verse demeliki identity matrix alinib solda
      raise ValueError("Gauss-Jordan failed: left side is not identity")


    inverse_matrix = augmented_A[:, n:] #butun setirleri amma ancaq nden sonraki sutunlari goturecek
    return inverse_matrix

    # Suggested Steps:
    # 1. Forward Elimination (getting upper triangular form)
    # Iterate through each row (pivot row `i` from 0 to n-1):
    # a. Find the pivot element `augmented_A[i, i]`.
    # b. If the pivot is zero, the matrix is singular. You may need to
    # implement pivoting (row swapping) for a more robust solution,
    # but for now, you can return None.
    # c. Normalize the pivot row by dividing it by the pivot element.
    # d. For every other row `j` (where `j != i`):
    # Subtract `augmented_A[j, i]` times the pivot row from row `j`.

    # 2. After the loop, the left side should be the identity matrix.
    # If not, something went wrong.

    # 3. Extract the inverse matrix from the right side of the
    # transformed augmented matrix.

    # Placeholder: Replace with your implementation

    # Check if the left side is indeed an identity matrix
    # A simple check could be to see if `np.allclose(left_side, np.identity(n))`
    # If it is, extract and return the right side (the inverse).

    # For now, returning None until implemented
    # Replace this with your extracted inverse
    # For example: inverse_A = augmented_A[:, n:]



# --- Calling the function for Part 3.1 ---
print("--- Part 3.1: Matrix Inverse from Scratch ---")
A_inv_scratch = invert_matrix(A.copy()) # Use a copy to keep original A intact
print_matrix("Inverse A (from scratch)", A_inv_scratch)


# ====================================================================
# Part 3.2: LU Decomposition from Scratch
# ====================================================================

def lu_decomposition(A):
    """
    Performs LU decomposition of a square matrix A using Doolittle's algorithm.

    Args:
        A (np.ndarray): A square numpy array.

    Returns:
        (np.ndarray, np.ndarray): A tuple of (L, U) matrices.
    """
    # Ensure the matrix is a float type
    A = A.astype(float)

    # Check if the matrix is square
    n = A.shape[0]
    if A.shape[1] != n:
        raise ValueError("Input matrix must be square.")

    # Initialize L as an identity matrix and U as a zero matrix
    L = np.identity(n)
    U = np.zeros((n, n))

    # --- YOUR CODE HERE ---
    # Implement the Doolittle algorithm.
    # Iterate through the matrix to calculate the elements of L and U.

    for i in range(n):
      for j in range(i,n):
        U[i, j] = A[i, j] - sum(L[i, k] * U[k, j] for k in range(i)) #1st part for computing U

      if U[i, i] == 0:
            raise ZeroDivisionError(f"Pivot U[{i},{i}] sıfırdır!")

      for j in range(i+1, n):
            L[j, i] = (A[j, i] - sum(L[j, k] * U[k, i] for k in range(i))) / U[i, i]

    # Suggested Steps:
    # For each `i` from 0 to n-1:
    # 1. Calculate the i-th row of U:
    # For `j` from `i` to `n-1`:
    # U[i, j] = A[i, j] - sum(L[i, k] * U[k, j] for k in range(i))
    #
    # 2. Calculate the i-th column of L:
    # For `j` from `i+1` to `n-1`:
    # L[j, i] = (A[j, i] - sum(L[j, k] * U[k, i] for k in range(i))) / U[i, i]
    #
    # Note: If U[i, i] is zero at any point, the decomposition may fail
    # without pivoting. Assume the given matrix A works without pivoting.

    # Placeholder: Replace with your implementation

    return L, U

# --- Calling the function for Part 3.2 ---
print("--- Part 3.2: LU Decomposition from Scratch ---")
L_scratch, U_scratch = lu_decomposition(A.copy())
print_matrix("L (from scratch)", L_scratch)
print_matrix("U (from scratch)", U_scratch)


# ====================================================================
# Part 3.3: NumPy Verification
# ====================================================================
print("--- Part 3.3: NumPy Verification ---")

# 1. Verifying the Matrix Invers=e
print("Verifying Matrix Inverse...")
A_inv_numpy = np.linalg.inv(A)
print_matrix("Inverse A (NumPy)", A_inv_numpy)

# 2. Verifying the LU Decomposition
print("Verifying LU Decomposition...")
# We check by multiplying L and U and see if we get back A
if L_scratch is not None and U_scratch is not None:
    product_LU = L_scratch @ U_scratch
    print_matrix("L @ U (from scratch)", product_LU)
    print_matrix("Original A (for comparison)", A)

    # A programmatic check for correctness
    is_correct = np.allclose(A, product_LU)
    print(f"Verification Check (A == L @ U): {is_correct}\n")
else:
    print("LU decomposition not yet implemented.\n")

# Optional: Compare with SciPy's LU decomposition
# Note: SciPy's version may include a permutation matrix P.
# P, L_scipy, U_scipy = scipy_lu(A)
# print_matrix("L (SciPy)", L_scipy)
# print_matrix("U (SciPy)", U_scipy)
# print(f"Verification with SciPy (P@L@U == A): {np.


# Optional: Compare with SciPy's LU decomposition  # that's my part

print("SciPy Verification ")
P, L_scipy, U_scipy = scipy_lu(A)
print_matrix("P (SciPy)", P)
print_matrix("L (SciPy)", L_scipy)
print_matrix("U (SciPy)", U_scipy)   # scipy de row swap olur ve bu P de saxlanilir amma yoxlayanda  P@l@U hamisi ele yenede A ni verir deye netice eyni olur baxmayaraqki men row swap etmemisdim.
# Verification: P @ L @ U should be equal to A
verification = np.allclose(P @ L_scipy @ U_scipy, A)
print(f"Verification with SciPy (P@L@U == A): {verification}\n")